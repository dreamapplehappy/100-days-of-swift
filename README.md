
## Days 26-34: Expanding your skills

+ [x] Project 4, part two [notes](./day-27/README.md)
    + [x] Building a basic layout
    + [x] Connecting SwiftUI to Core ML
    + [x] Cleaning up the user interface

+ [x] Day 26 – Project 4, part one [notes](./day-26/README.md)
    + [x] BetterRest: Introduction
    + [x] Entering numbers with Stepper
    + [x] Selecting dates and times with DatePicker
    + [x] Working with dates
    + [x] Training a model with Create ML

## Day 25: Consolidation II

+ [x] Day 25 – Milestone: Projects 1-3 [notes](./day-25/README.md)
    + [x] What you learned
    + [x] Key points
    + [x] Challenge

## Days 16-24: Starting SwiftUI

+ [x] Day 24 – Project 3, part two [notes](./day-24/README.md)
    + [x] Views and modifiers: Wrap up
    + [x] Review for Project 3: Views and Modifiers

+ [x] Day 23 – Project 3, part one [notes](./day-23/README.md)
    + [x] Views and modifiers: Introduction
    + [x] Why does SwiftUI use structs for views?
    + [x] What is behind the main SwiftUI view?
    + [x] Why modifier order matters
    + [x] Why does SwiftUI use “some View” for its view type?
    + [x] Conditional modifiers
    + [x] Environment modifiers
    + [x] Views as properties
    + [x] View composition
    + [x] Custom modifiers
    + [x] Custom containers

+ [x] Day 22 – Project 2, part three [notes](./day-22/README.md)
    + [x] Guess the Flag: Wrap up
    + [x] Review for Project 2: Guess the Flag

+ [x] Day 21 – Project 2, part two [notes](./day-21/README.md)
    + [x] Stacking up buttons
    + [x] Showing the player’s score with an alert
    + [x] Styling our flags

+ [x] Day 20 – Project 2, part one [notes](./day-20/README.md)
    + [x] Guess the Flag: Introduction
    + [x] Using stacks to arrange views
    + [x] Colors and frames
    + [x] Gradients
    + [x] Buttons and images
    + [x] Showing alert messages

+ [x] Day 19 – Challenge day [notes](./day-19/README.md)

+ [x] Day 18 – Project 1, part three [notes](./day-18/README.md)
    + [x] WeSplit: Wrap up
    + [x] Review for Project 1: WeSplit

+ [x] Day 17 – Project 1, part two [notes](./day-17/README.md)
    + [x] Reading text from the user with TextField
    + [x] Creating pickers in a form
    + [x] Adding a segmented control for tip percentages
    + [x] Calculating the total per person

+ [x] Day 16 - Project 1, part one [notes](./day-16/README.md)
    + [x] WeSplit: Introduction
    + [x] Understanding the basic structure of a SwiftUI app
    + [x] Creating a form
    + [x] Adding a navigation bar
    + [x] Modifying program state
    + [x] Binding state to user interface controls
    + [x] Creating views in a loop

## Days 13-15: Consolidation I

+ [x] Day 15 - Swift review, day three [notes](./day-15/README.md)
    + [x] 1.Properties
    + [x] 2.Static properties and methods
    + [x] 3.Access control
    + [x] 4.Polymorphism and typecasting
    + [x] 5.Closures

+ [x] Day 14 - Swift review, day two [notes](./day-14/README.md)
    + [x] 1.Functions
    + [x] 2.Optionals
    + [x] 3.Optional chaining
    + [x] 4.Enumerations
    + [x] 5.Structs
    + [x] 6.Classes

+ [x] Day 13 - Swift review, day one [notes](./day-13/README.md)
    + [x] 1.Variables and constants
    + [x] 2.Types of Data
    + [x] 3.Operators
    + [x] 4.String interpolation
    + [x] 5.Arrays
    + [x] 6.Dictionaries
    + [x] 7.Conditional statements
    + [x] 8.Loops
    + [x] 9.Switch case

## Days 1-12: Introduction to Swift

+ [x] Day 12 - optionals, unwrapping, and typecasting [notes](./day-12/README.md)
    + [x] 1.Handling missing data
        + [x] Optional: Why does Swift have optionals?
        + [x] Test: Handling missing data
    + [x] 2.Unwrapping optionals
        + [x] Optional: Why does Swift make us unwrap optionals?
        + [x] Test: Unwrapping optionals
    + [x] 3.Unwrapping with guard
        + [x] Optional: When to use guard let rather than if let
        + [x] Test: Unwrapping with guard
    + [x] 4.Force unwrapping
        + [x] Optional: When should you force unwrap optionals in Swift?
        + [x] Test: Force unwrapping
    + [x] 5.Implicitly unwrapped optionals
        + [x] Optional: Why does Swift need both implicitly unwrapped optionals and regular optionals?
        + [x] Test: Implicitly unwrapped optionals
    + [x] 6.Nil coalescing
        + [x] Optional: When should you use nil coalescing in Swift?
        + [x] Test: Nil coalescing
    + [x] 7.Optional chaining
        + [x] Optional: Why is optional chaining so important?
        + [x] Test: Optional chaining
    + [x] 8.Optional try
        + [x] Optional: When should you use optional try?
        + [x] Test: Optional try
    + [x] 9.Failable initializers
        + [x] Optional: Why would you want a failable initializer?
        + [x] Test: Failable initializers
    + [x] 10.Typecasting
        + [x] Optional: When is type casting useful in Swift?
        + [x] Test: Typecasting
    + [x] 11.Optionals summary
        + [x] Test: Optionals

+ [x] Day 11 - protocols, extensions, and protocol extensions [notes](./day-11/README.md)
    + [x] 1.Protocols
        + [x] Optional: Why does Swift need protocols?
        + [x] Test: Protocols
    + [x] 2.Protocol inheritance
        + [x] Optional: When should we use protocol inheritance?
        + [x] Test: Protocol inheritance
    + [x] 3.Extensions
        + [x] Optional: When should you use extensions in Swift?
        + [x] Test: Extensions
    + [x] 4.Protocol extensions
        + [x] Optional: When are protocol extensions useful in Swift?
        + [x] Test: Protocol extensions
    + [x] 5.Protocol-oriented programming
        + [x] Optional: How is protocol-oriented programming different from object-oriented programming?
        + [x] Test: Protocol-oriented programming
    + [x] 6.Protocols and extensions summary
        + [x] Test: Protocols and extensions

+ [x] Day 10 - classes and inheritance [notes](./day-10/README.md)
    + [x] 1.Creating your own classes
        + [x] Optional: Why does Swift have both classes and structs?
        + [x] Test: Creating your own classes
    + [x] 2.Class inheritance
        + [x] Optional: Why don’t Swift classes have a memberwise initializer?
        + [x] Test: Class inheritance
    + [x] 3.Overriding methods
        + [x] Optional: When would you want to override a method?
        + [x] Test: Overriding methods
    + [x] 4.Final classes
        + [x] Optional: Which classes should be declared as final?
        + [x] Test: Final classes
    + [x] 5.Copying objects
        + [x] Optional: Why do copies of a class share their data?
        + [x] Test: Copying objects
    + [x] 6.Deinitializers
        + [x] Optional: Why do classes have deinitializers and structs don’t?
        + [x] Test: Deinitializers
    + [x] 7.Mutability
        + [x] Optional: Why can variable properties in constant classes be changed?
        + [x] Test: Mutability
    + [x] 8.Classes summary
        + [x] Test: Classes

+ [x] Day 9 - access control, static properties, and laziness [notes](./day-09/README.md)
    + [x] 1.Initializers
        + [x] Optional: How do Swift’s memberwise initializers work?
        + [x] Test: Initializers
    + [x] 2.Referring to the current instance
        + [x] Optional: When would you use self in a method?
        + [x] Test: Referring to the current instance
    + [x] 3.Lazy properties
        + [x] Optional: When should properties be lazy?
        + [x] Test: Lazy properties
    + [x] 4.Static properties and methods
        + [x] Optional: What’s the point of static properties and methods in Swift?
        + [x] Test: Static properties and methods
    + [x] 5.Access control
        + [x] Optional: What’s the point of access control?
        + [x] Test: Access control
    + [x] 6.Structs summary
        + [x] Test: Structs
     
+ [x] Day 8 - structs, properties, and method [notes](./day-08/README.md)
    + [x] 1.Creating your own structs
        + [x] Optional: What’s the difference between a struct and a tuple?
        + [x] Test: Creating your own structs
    + [x] 2.Computed properties
        + [x] Optional: When should you use a computed property or a stored property?
        + [x] Test: Computed properties
    + [x] 3.Property observers
        + [x] Optional: When should you use property observers?
        + [x] Optional: When should you use willSet rather than didSet?
        + [x] Test: Property observers
    + [x] 4.Methods
        + [x] Optional: What’s the difference between a function and a method?
        + [x] Test: Methods
    + [x] 5.Mutating methods
        + [x] Optional: Why do we need to mark some methods as mutating?
        + [x] Test: Mutating methods
    + [x] 6.Properties and methods of strings
        + [x] Optional: Why are strings structs in Swift?
        + [x] Test: Properties and methods of strings
    + [x] 7.Properties and methods of arrays
        + [x] Optional: Why do strings behave differently from arrays in Swift?
        + [x] Test: Properties and methods of arrays
          
+ [x] Day 7 - Closures, part two [notes](./day-07/README.md)
    + [x] 1.Using closures as parameters when they accept parameters
        + [x] Optional: When would closures with parameters be used as parameters?
        + [x] Test: Using closures as parameters when they accept parameters
    + [x] 2.Using closures as parameters when they return values
        + [x] Optional: When would you use closures with return values as parameters to a function?
        + [x] Test: Using closures as parameters when they return values
    + [x] 3.Shorthand parameter names
        + [x] Optional: When should you use shorthand parameter names?
        + [x] Test: Shorthand parameter names
    + [x] 4.Closures with multiple parameters
        + [x] Optional: How many parameters can a closure take?
        + [x] Test: Closures with multiple parameters
    + [x] 5.Returning closures from functions
        + [x] Optional: Returning closures from functions
        + [x] Test: Returning closures from functions
    + [x] 6.Capturing values
        + [x] Optional: Why do Swift’s closures capture values?
        + [x] Test: Capturing values
    + [x] 7.Closures summary
        + [x] Test: Closures
        
+ [x] Day 6 – Closures, part one [notes](./day-06/README.md)   
    + [x] 1.Creating basic closures
        + [x] Optional: What the heck are closures and why does Swift love them so much?
        + [x] Test: Creating basic closures
    + [x] 2.Accepting parameters in a closure
        + [x] Optional: Why are Swift’s closure parameters inside the braces?
        + [x] Test: Accepting parameters in a closure
    + [x] 3.Returning values from a closure
        + [x] Optional: How do you return a value from a closure that takes no parameters?
        + [x] Test: Returning values from a closure
    + [x] 4.Closures as parameters
        + [x] Optional: Why would you want to use closures as parameters?
        + [x] Test: Closures as parameters
    + [x] 5.Trailing closure syntax
        + [x] Optional: Why does Swift have trailing closure syntax?
        + [x] Test: Trailing closure syntax
        
+ [x] Day 5 – Functions [notes](./day-05/README.md)
    + [x] 1.Writing functions
        + [x] Optional: What code should be put in a function?
        + [x] Test: Writing functions
    + [x] 2.Accepting parameters
        + [x] Optional: How many parameters should a function accept?
        + [x] Test: Accepting parameters
    + [x] 3.Returning values
        + [x] Optional: When is the return keyword not needed in a Swift function?
        + [x] Optional: How can you return two or more values from a function?
        + [x] Test: Returning values
    + [x] 4.Parameter labels
        + [x] Optional: Why does Swift use parameter labels?
        + [x] Test: Parameter labels
    + [x] 5.Omitting parameter labels
        + [x] Optional: When should you omit a parameter label?
        + [x] Test: Omitting parameter labels
    + [x] 6.Default parameters
        + [x] Optional: When to use default parameters for functions
        + [x] Test: Default parameters
    + [x] 7.Variadic functions
        + [x] Optional: When to use variadic functions
        + [x] Test: Variadic functions
    + [x] 8.Writing throwing functions
        + [x] Optional: When should you write throwing functions?
        + [x] Test: Writing throwing functions
    + [x] 9.Running throwing functions
        + [x] Optional: Why does Swift make us use try before every throwing function?
        + [x] Test: Running throwing functions
    + [x] 10.inout parameters
        + [x] Optional: When should you use inout parameters?
        + [x] Test: inout parameters
    + [x] 11.Functions summary
        + [x] Test: Test
        
+ [x] Day 4 – loops, loops, and more loops [notes](./day-04/README.md)
    + [x] 1.For loops
        + [x] Optional: Why does Swift use underscores with loops?
        + [x] Test: For loops
    + [x] 2.While loops
        + [x] Optional: When should you use a while loop?
        + [x] Test: While loops
    + [x] 3.Repeat loops
        + [x] Optional: When should you use a repeat loop?
        + [x] Test: Repeat loops
    + [x] 4.Exiting loops
        + [x] Optional: Why would you want to exit a loop?
        + [x] Test: Exiting loops
    + [x] 5.Exiting multiple loops
        + [x] Optional: Why does Swift have labeled statements?
        + [x] Test: Exiting multiple loops
    + [x] 6.Skipping items
        + [x] Optional: When to use break and when to use continue
        + [x] Test: Skipping items
    + [x] 7.Infinite loops
        + [x] Optional: Why would you want to make an infinite loop?
        + [x] Test: Infinite loops
    + [x] 8.Looping summary
        + [x] Test: Looping

+ [x] Day 3 – operators and conditions [notes](./day-03/README.md)
    + [x] 1.Arithmetic Operators
        + [x] Optional: Why can’t Swift add a Double to an Int?
        + [x] Optional: Why does Swift have a dedicated division remainder operator?
        + [x] Test: Arithmetic operators
    + [x] 2.Operator overloading
        + [x] Optional: Why does Swift need operator overloading?
        + [x] Test: Operator overloading
    + [x] 3.Compound assignment operators
        + [x] Optional: Why does Swift have compound assignment operators?
        + [x] Test: Compound assignment operators
    + [x] 4.Comparison operators
        + [x] Optional: How does Swift let us compare many types of data?
        + [x] Test: Comparison operators
    + [x] 5.Conditions
        + [x] Optional: What’s the difference between if and else if?
        + [x] Test: Conditions
    + [x] 6.Combining conditions
        + [x] Optional: How to check multiple conditions
        + [x] Test: Combining conditions
    + [x] 7.The ternary operator
        + [x] Optional: When should you use the ternary operator in Swift?
        + [x] Test: The ternary operator
    + [x] 8.Switch statements
        + [x] Optional: When should you use switch statements rather than if?
        + [x] Test: Switch statements
    + [x] 9.Range operators
        + [x] Optional: Why does Swift have two range operators?
        + [x] Test: Range operators
    + [x] 10.Operators and conditions summary
        + [x] Test: Operators and conditions

+ [ ] Day 2 arrays, dictionaries, sets, and enums [notes](./day-02/README.md)
    + [x] 1.Arrays
        + [x] Optional: Why does Swift have arrays?
        + [x] Test: Arrays
    + [x] 2.Sets
        + [x] Optional: Why are sets different from arrays in Swift?
        + [x] Test: Sets
    + [x] 3.Tuples
        + [x] Optional: How are tuples different from arrays in Swift?
        + [x] Test: Tuples
    + [x] 4.Arrays vs sets vs tuples
        + [x] Optional: When should you use an array, a set, or a tuple in Swift?
        + [x] Test: Arrays vs sets vs tuples
    + [x] 5.Dictionaries
        + [x] Optional: Why does Swift have dictionaries as well as arrays?
        + [x] Test: Dictionaries
    + [x] 6.Dictionary default values
        + [ ] Optional: Why does Swift have default values for dictionaries?
        + [ ] Test: Dictionary default values
    + [ ] 7.Creating empty collections
        + [ ] Optional: Why would you want to create an empty collection?
        + [ ] Test: Creating empty collections
    + [ ] 8.Enumerations
        + [ ] Optional: Why does Swift need enums?
        + [ ] Test: Enumerations
    + [ ] 9.Enum associated values
        + [ ] Optional: Why would you want to associate a value with an enum case?
        + [ ] Test: Enum associated values
    + [ ] 10.Enum raw values
        + [ ] Optional: Why do Swift’s enums have raw values?
        + [ ] Test: Enum raw values
    + [ ] 11.Complex types: Summary
        + [ ] Test: Complex types

+ [x] Day 1 – variables, simple data types, and string interpolation [notes](./day-01/README.md)
    + [x] 1.Variables
        + [x] Optional: Why does Swift have variables?
        + [x] Test: Variables
    + [x] 2.Strings and integers
        + [x] Optional: Why is Swift a type-safe language?
        + [x] Test: Strings and integers
    + [x] 3.Multi-line strings
        + [x] Optional: Why does Swift need multi-line strings?  
        + [x] Test: Multi-line strings
    + [x] 4.Doubles and Booleans
        + [x] Optional: Why does Swift need both Doubles and Integers?
        + [x] Test: Doubles and Booleans
    + [x] 5.String interpolation
        + [x] Optional: Why does Swift have string interpolation?  
        + [x] Test: String interpolation
    + [x] 6.Constants 
        + [x] Optional: Why does Swift have constants as well as variables?
        + [x] Test: Constants
    + [x] 7.Type annotations
        + [x] Optional: Why does Swift have type annotations?
        + [x] Test: Type annotations
    + [x] 8.Simple types: Summary
        + [x] Test: Simple types
